# Многозадачность и конкурентность

## Модели обработки в сервисах

| Сервис | Модель конкурентности | Обоснование |
|--------|------------------------|-------------|
| **User Service** (Java) | Многопоточная (thread per request) с пулом потоков. Блокирующие операции с БД вынесены в отдельные потоки. | Java Spring Boot традиционно использует сервлеты с thread pool. Для высоких нагрузок используется асинхронный non-blocking (WebFlux), но здесь выбрана классическая модель с горизонтальным масштабированием. |
| **Workout Service** (Python/FastAPI) | Асинхронная (asyncio) для I/O-bound операций. Тяжёлые вычисления (обработка GPX) выносятся в фоновые задачи. | FastAPI поддерживает async/await, что позволяет эффективно обрабатывать множество одновременных запросов к БД и внешним API. |
| **Social Service** (Node.js) | Асинхронная, событийно-ориентированная (single-threaded event loop). Для CPU-bound задач используются worker threads. | Node.js оптимизирован для I/O, хорошо подходит для real-time чатов и ленты. |
| **Gamification Service** (Python/Django) | Синхронная (thread per request) для API, но для обновления лидербордов используется асинхронная обработка через Celery или фоновые задачи. | Django по умолчанию синхронный, но для операций в Redis (быстрые) это не критично. Тяжёлые вычисления выносятся в очередь. |
| **Notification Service** (Node.js) | Асинхронная, потребляет сообщения из Kafka и отправляет через внешние API с использованием неблокирующих вызовов. | Высокая пропускная способность при отправке уведомлений. |
| **Analytics Service** (Python) | Потребление Kafka – асинхронное (aiokafka). Запись в ClickHouse – bulk insert. ETL-задачи (Airflow) – оркестрация DAG. | Оптимизировано для больших объёмов. |

## Асинхронная обработка через очереди (Kafka)

- **Гарантии доставки**: at-least-once, идемпотентность обработчиков.
- **Партиционирование**: для каждого топика партиции по ключу (например, `user_id`), чтобы обеспечить порядок событий для одного пользователя.
- **Consumer groups**: каждая группа (сервис) масштабируется независимо, потребляя свои партиции.

## Обработка пиковых нагрузок

- **Rate limiting** на API Gateway: предотвращает превышение допустимого числа запросов от одного клиента.
- **Автомасштабирование** (Kubernetes HPA): добавление реплик сервисов при росте нагрузки (CPU, memory, custom metrics – длина очереди).
- **Буферизация через Kafka**: пиковые нагрузки сглаживаются, так как продюсеры могут писать быстрее, чем консьюмеры, но Kafka хранит события.
- **Backpressure**: в асинхронных сервисах реализовано ограничение на количество одновременно обрабатываемых сообщений (prefetch count).

## Примеры конкурентных сценариев

### Одновременная запись тренировки и обновление лидерборда
- Несколько пользователей завершают тренировку одновременно.
- Workout Service сохраняет данные, публикует события.
- Gamification Service получает события, обновляет Redis (sorted set) с использованием атомарных операций (`ZINCRBY`), что гарантирует корректность рейтинга даже при параллельных обновлениях.

### Отправка массовых уведомлений (например, о старте челленджа)
- Promo Service публикует событие с типом `broadcast`.
- Notification Service имеет несколько консьюмеров в группе, каждый обрабатывает свою партицию.
- Для предотвращения дублирования уведомлений используется идемпотентность (проверка в Redis, было ли уже отправлено уведомление для данного пользователя по данному событию).

### Обработка транзакций при привязке инвентаря к тренировке
- Тренировка сохраняется, одновременно обновляется пробег инвентаря.
- Inventory Service получает событие, но может быть несколько событий для одного предмета (если пользователь тренируется несколько раз подряд). Используется оптимистическая блокировка (версионность) в PostgreSQL для избежания потерянных обновлений.