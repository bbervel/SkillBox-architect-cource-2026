# ADR-002: Полиглотное хранение данных (Polyglot Persistence)

## Статус
Принято

## Контекст
Разные сервисы системы имеют различные требования к хранению данных:
- User Service — транзакционные данные, строгая согласованность.
- Workout Service — геоданные, временные ряды (пульс, темп), большие файлы (GPX-треки).
- Social Service — сообщения, графы связей, полнотекстовый поиск.
- Gamification Service — быстрые лидерборды, рейтинги в реальном времени.
- Analytics Service — большие объёмы событий для аналитики.

## Рассмотренные альтернативы
1. **Единая реляционная СУБД для всех сервисов** (например, PostgreSQL).
2. **Полиглотное хранение** — каждый сервис выбирает БД под свои задачи.

## Решение
Использовать полиглотное хранение данных.

### Обоснование
- **Производительность** — разные типы данных требуют разных моделей хранения и доступа.
- **Эффективность** — специализированные СУБД дают лучшие характеристики (например, Redis для лидербордов, TimescaleDB для временных рядов).
- **Масштабируемость** — можно масштабировать каждое хранилище независимо.
- **Соответствует микросервисной архитектуре** — каждый сервис владеет своей базой данных.

Единая БД отвергнута, так как создаёт связанность сервисов на уровне данных и не позволяет оптимизировать под разные задачи.

## Последствия
### Положительные
- Оптимальная производительность для каждого сценария.
- Возможность использовать лучшие практики и инструменты.

### Отрицательные / Требующие внимания
- Усложнение администрирования (разные СУБД, разные навыки).
- Необходимость поддержки согласованности данных между сервисами (через события и саги).
- Риск увеличения затрат на лицензии и инфраструктуру.

### План реализации
- User, Inventory, Promo — PostgreSQL.
- Workout — PostgreSQL + TimescaleDB + S3.
- Social — MongoDB + Neo4j + Elasticsearch.
- Gamification — PostgreSQL + Redis.
- Analytics — ClickHouse + Kafka.